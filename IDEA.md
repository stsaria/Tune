# P2Pチャットプロトコル仕様書

## 前提条件

- ノードは「A、B、C、D、E...」と続くものとする
- 各ノードのIPアドレスはある程度ランダムに分散している
- 全ノードは最低限、上り・下りともに1Mbpsの通信速度を持つ
- 致命的な接続失敗がない限り、全ノードが均等に処理を実行し、ネットワークから離脱しない

## ノード間の接続方法

- UDP通信を使用し、何らかの方法でポートが開放された状態（NAT越えが完了済み）
- Full Cone NATのノードは特に頼りになるノードとして扱われる

## ID形式

### エンコード
- Base64でエンコードされたJSON形式

### 構造
```json
{
  "t": "チャット名/カテゴリ名",
  "ips": [
    "IPアドレス:ポート番号",
    "IPアドレス:ポート番号"
  ]
}
```

### 例
```json
{
  "t": "カテゴリタイトル",
  "ips": [
    "142.95.104.10:14952",
    "114.164.220.173:1752"
  ]
}
```

**注意:** クライアントは迷惑パケットの大量送信を防ぐため、複数のリクエストがある場合は一部を無視する場合がある。

## ネットワークへの参加（チャット開始）

### 手順

1. **IDファイルの取得**
  - 参加したいチャットカテゴリに対応するIDファイルをネットワークから取得
  - 複数のカテゴリが含まれている場合もある

   例（Base64デコード前）:
   ```json
   {
     "t": "VALORANT好き",
     "ips": [
       "142.95.104.10:12045",
       "114.164.220.173:10294"
     ]
   }
   ```

2. **ノードへの接続**
  - 約5つのノードに対してIDを送信

3. **ノード情報の更新**
  - 接続先ノードから不足しているノード情報を受信
  - 古いIDファイルでも問題なくネットワーク参加が可能
  - Full Cone NATのノードが判明した場合、頼りになるノードリストに追加

4. **定期的な更新**
  - 全ノードが定期的にこの処理を繰り返す
  - 不足ノード情報を返す際は、ping/pongでノードの生存確認を実施

*各ノードが今の時点で、人が多すぎると判断した場合には、ノード情報を返してくれなかったりする可能性はあります。

## メッセージ処理

### 投稿

#### 通常の投稿
```json
{
  "c": "メッセージ内容",
  "ts": タイムスタンプ,
  "hash": "SHA256ハッシュ値(c+ts)",
  "sig": "デジタル署名"
}
```

**例:**
```json
{
  "c": "結構自分はゲッコーを使うかな。スパイク設置を相棒がやってくれて、その間も戦えるから。",
  "ts": 1753321039,
  "hash": "4a0ac3523b61b00a956da27a63a2ffb7daf1c90600d2f7f7312c6cf1ea8bc286", // 結構自分はゲッコーを使うかな。スパイク設置を相棒がやってくれて、その間も戦えるから。1753321039
  "sig": "4ddf02a6b06339b082b9a0003b62218141cae50e84371f46036707f11962fe4d9a21bd0b494892c7e3083004835d974af68d73882c85fed26c0a1dac35a67e08"
}
```

**処理:**
1. メッセージ内容を作成し、自分のノードに保存
2. 内容とタイムスタンプを合わせたSHA256ハッシュを生成
3. ハッシュに対するデジタル署名を追加

#### リプライ投稿
```json
{
  "c": "メッセージ内容",
  "ts": タイムスタンプ,
  "from": "リプライ元のIP:Port",
  "frompub": "リプライ元の公開鍵",
  "fromhash": "リプライ元ハッシュ",
  "hash": "SHA256ハッシュ値(c+ts+frompub+fromhash)",
  "sig": "デジタル署名"
}
```

**例:**
```json
{
  "c": "結構初心者向けだからわかりやすいしね〜",
  "ts": 1753321099,
  "from": "142.95.104.10:12045",
  "frompub": "e7a9662649fe6f69d1e2491cbf2f52711b207dc0d2f01e3c618f458b7c3b0f5a",
  "fromhash": "4a0ac3523b61b00a956da27a63a2ffb7daf1c90600d2f7f7312c6cf1ea8bc286",
  "hash": "e36951dcd5c6b8b8f5de808fcd9e090244788209e0a5970549b01664695b1713", //結構初心者向けだからわかりやすいしね〜1753321099e7a9662649fe6f69d1e2491cbf2f52711b207dc0d2f01e3c618f458b7c3b0f5a4a0ac3523b61b00a956da27a63a2ffb7daf1c90600d2f7f7312c6cf1ea8bc286
  "sig": "8739f88806a7830d594b0edefe30264795efc8414f464f1a67408f9a1d31947e702f77467556995a77f2fe50c176f7bf5bfdc48b78801e31312dac87b7d63401"
}
```

### 受信・処理

**注意:** 処理方法はクライアント実装によって異なる場合がある。

#### 処理手順

1. **メッセージ取得**
  - 各ノードからメッセージをリクエスト（byte制限を設定する場合あり）

2. **初期分類**
  - 全メッセージを単一リスト（リストA）に格納
  - `from`属性のないメッセージのみを抽出し、新しいリスト（リストB）に格納

3. **階層構造の構築**
  - リストBの各メッセージに対して再帰関数を実行
  - `fromhash`が一致するメッセージを該当メッセージの配下に配置
  - 処理済みメッセージはリストAから除外

4. **継続処理**
  - リプライが発見された場合、さらに処理を継続
  - リストBが大きくなりすぎた場合は処理を中断する場合あり

5. **未解決リプライの処理**
  - 処理が完了してもリストAに`from`付きメッセージが残っている場合
  - `from`に記載された公開鍵から接続済みリストでホストを検索
  - 該当ホストに`fromhash`を送信してメッセージを取得
  - 取得したメッセージも`from`付きの場合は再帰的に処理継続
  - リストAが大きくなりすぎるまで処理を継続

6. **エラーハンドリング**
  - `from`探索時点で処理が中断された場合は「不明なリプライ元」として扱う

7. **出力**
  - 処理完了後、UIなどに結果を出力

## セキュリティ・署名

### 署名アルゴリズム
- **必須:** Ed25519デジタル署名アルゴリズムを使用

### Hello交換
#### Hello送信
```json
{
  "t": "hel",
  "d": {
    "name": "ユーザー名",
    "pub": "Ed25519公開鍵（16進数）"
  }
}
```

**例:**
```json
{
  "t": 0,
  "d": {
    "name": "Saria",
    "pub": "e7a9662649fe6f69d1e2491cbf2f52711b207dc0d2f01e3c618f458b7c3b0f5a"
  }
}
```

#### Hello応答
```json
{
  "t": 1,
  "d": {
    "name": "ユーザー名",
    "pub": "Ed25519公開鍵（16進数）"
  }
}
```

**例:**
```json
{
  "t": 1,
  "d": {
    "name": "Airas",
    "pub": "5687b896901b855fd03751b4d0a6f7ebcb3746247bb4e6136fb3f7f952bf9702"
  }
}
```

### 認証方式
- メッセージの署名フィールド（`sig`）にEd25519署名を格納
- **重要:** 公開鍵をユーザー識別子として使用する
  - 理由: 証明書が存在せず、特定のホストとの紐付けができないため
  - 公開鍵が実質的なユーザー名となる
- Hello受信時は必ず応答を返す