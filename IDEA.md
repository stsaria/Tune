**# P2Pチャットプロトコル

## 前提
- ノード「A B C D E…」と続くとする
- 各ノードのIPはある程度ランダムだと言える
- 全ノードは少なくとも上り下が1MB毎秒の速度である
## ノード間の接続方法
- UDPでポートがなんらかの方法で解放された状態（NAT越え）
- 致命的な接続の失敗がない限りは全ノードの仕事はみんな一律にこなせてるとし、バイバイしない
## ID
- IDはBase64でエンコードされている
### 中身
- JSON
- 先頭にチャット名が書かれている
- 知っているノード群のIPv4とポートのリスト
- ただ、クライアントは迷惑なパケットをたくさん送ることはできないから、複数ある場合無視する場合もある

例
```
{“t”:“カテゴリタイトル”,“ips”:[“142.95.104.10:14952”,”114.164.220.173:1752”]}
```
## ネットワークへの参加(=チャットを始める)
- まず、したいチャットのカテゴリに沿ったノードだけが書いてあるIDファイル（複数のカテゴリが入っている場合もある）をネットから拾ってくる
  例として(base64デコード前):
```
{“t”:“VALORANT好き",“ips”:[“142.95.104.10:12045”,”114.164.220.173:10294”]}
```
- 接続後、5つぐらいのノードに対して、このIDを送る。
- 送ったら、不足しているノードを返してくれるから、古いIDでも問題なくネットワークに参加できる。
- 不足ノードを返してくれると同時に、NATがFull Coneだとわかったら頼りになるノードリスト（不足ノードの参照元）に入れる。
- 定期的にこれをすべてのノードが繰り返す。（繋げないノードを送らないように、不足ノードを返すときにpingしてpongするかチェックする）
## メッセージ
### 投稿する
- メッセージの内容を書いて、"自分のところに"保存する。
- ハッシュ(sha256)を書く（内容とタイムスタンプを合わせたハッシュ）
- 最後にハッシュの署名を書く（詳しい暗号化は後で）
  例えとして:
```
{"c":"結構自分はゲッコーを使うかな。スパイク設置を相棒がやってくれて、その間も戦えるから。", "ts":1753321039, "hash":"4a0ac3523b61b00a956da27a63a2ffb7daf1c90600d2f7f7312c6cf1ea8bc286", "sig":"4ddf02a6b06339b082b9a0003b62218141cae50e84371f46036707f11962fe4d9a21bd0b494892c7e3083004835d974af68d73882c85fed26c0a1dac35a67e08"}
```
### 投稿する（リプライとして）
- fromというリプライ元の公開鍵を書く
- fromhashというリプライ元のハッシュを書く
- メッセージ自体のハッシュの後ろに更にリプライ元ハッシュも書く
  例えとして:
```
{"c":"結構初心者向けだからわかりやすいしね〜", "ts"::1753321099, "from":"142.95.104.10:12045", "fromhash":"4a0ac3523b61b00a956da27a63a2ffb7daf1c90600d2f7f7312c6cf1ea8bc286", "hash":"6da87714920c94848041c28c535061303659df09991fa2b6cb0e6f7c2ba4a111", "sig":"badc0c50b2fb603a0e267c2ac6f43c54e97b770e214099e439814ab1333a2e8c7f68a3a9617ca0d3a1af9abb78cf34e6188d0c951b175899a2a2870ccbf5330f"}
```
### 受信して処理する
処理はクライアントによって違う可能性あり
- 各ノードからメッセージをリクエストする。（bytelimitを設定する場合あり）
- まずメッセージの単一なリスト（a）にする
- from属性がついていないものだけピックして、新しいリスト（b）に入れる。
- 最初にforで再帰関数を呼んでで一つづつピックして、fromhashがそれと同じものはまたその配下に置く。
- リストbに挿入されたものはリストaから除外する。
- もし、リプライが発見されたら次も試してみる。
- リストbがでかくなりすぎたら処理を止める場合もある。
- 処理が意図的に止まったわけではなく、まだリストaに残ってるfrom付きのメッセージは随時fromに書いてある公開鍵からホストを接続済みリストから見つけて、ホストにfromhashを送ってメッセージを取得する。
- もし、メッセージを取得したときにそれもfrom付きだったときは再帰関数を呼び直してfromがなくなるか、リストaがでかくなり過ぎるまで続ける。
- from探索の時点で止まった場合は、不明なリプライ元として扱う。
- その後UIなどに出力させる。
## 署名等のセキュリティ
- 署名はed25519でないとならない
- hello時に名前と一緒に公開鍵も送っておく
  例えとして:
```
{"t":"hel","d":{"name":"Saria","pub":"e7a9662649fe6f69d1e2491cbf2f52711b207dc0d2f01e3c618f458b7c3b0f5a"}}
```
- 必ず送られてきたら自分も返す
  例えとして:
```
{"t":"rehel","d":{"name":"Airas","pub":"5687b896901b855fd03751b4d0a6f7ebcb3746247bb4e6136fb3f7f952bf9702"}}
```
- メッセージの後ろに署名を書く
- 公開鍵は名前として使います。なぜなら、証明書がなく、ホストと紐付けられないからです。